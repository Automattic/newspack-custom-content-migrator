<?php

namespace NewspackCustomContentMigrator\Migrator\General;

use \NewspackCustomContentMigrator\Migrator\InterfaceMigrator;
use \NewspackCustomContentMigrator\MigrationLogic\Posts;
use \WP_CLI;

class PostsMigrator implements InterfaceMigrator {

	/**
	 * `meta_key` which gets assigned to exported posts, contains the original post ID.
	 */
	const META_KEY_ORIGINAL_ID = 'newspack_custom_content_migrator-original_post_id';

	/**
	 * @var string Staging site pages export file name.
	 */
	const STAGING_PAGES_EXPORT_FILE = 'newspack-staging_pages_all.xml';

	/**
	 * @var string Log file for shortcodes manipulation.
	 */
	const SHORTCODES_LOGS = 'posts_shorcodes_migrator.log';

	/**
	 * @var null|InterfaceMigrator Instance.
	 */
	private static $instance = null;

	/**
	 * @var Posts.
	 */
	private $posts_logic = null;

	/**
	 * Constructor.
	 */
	private function __construct() {
		$this->posts_logic = new Posts();
	}

	/**
	 * Singleton get_instance().
	 *
	 * @return InterfaceMigrator|null
	 */
	public static function get_instance() {
		$class = get_called_class();
		if ( null === self::$instance ) {
			self::$instance = new $class();
		}

		return self::$instance;
	}

	/**
	 * See InterfaceMigrator::register_commands.
	 */
	public function register_commands() {
		WP_CLI::add_command(
			'newspack-content-migrator export-posts',
			array( $this, 'cmd_export_posts' ),
			array(
				'shortdesc' => 'Exports posts/pages by post-IDs to an XML file using `wp export`.',
				'synopsis'  => array(
					array(
						'type'        => 'assoc',
						'name'        => 'output-dir',
						'description' => 'Output directory, no ending slash.',
						'optional'    => false,
						'repeating'   => false,
					),
					array(
						'type'        => 'assoc',
						'name'        => 'output-xml-file',
						'description' => 'Output XML file name.',
						'optional'    => false,
						'repeating'   => false,
					),
					array(
						'type'        => 'assoc',
						'name'        => 'post-ids',
						'description' => 'CSV post/page IDs to migrate.',
						'optional'    => true,
						'repeating'   => false,
					),
				),
			)
		);

		WP_CLI::add_command(
			'newspack-content-migrator import-posts',
			array( $this, 'cmd_import_posts' ),
			array(
				'shortdesc' => 'Imports custom posts from the XML file generated by `wp export`.',
				'synopsis'  => array(
					array(
						'type'        => 'assoc',
						'name'        => 'file',
						'description' => 'XML file full path.',
						'optional'    => false,
						'repeating'   => false,
					),
				),
			)
		);

		WP_CLI::add_command(
			'newspack-content-migrator export-all-staging-pages',
			array( $this, 'cmd_export_all_staging_site_pages' ),
			array(
				'shortdesc' => 'Exports all Pages from the Staging site.',
				'synopsis'  => array(
					array(
						'type'        => 'assoc',
						'name'        => 'output-dir',
						'description' => 'Output directory, no ending slash.',
						'optional'    => false,
						'repeating'   => false,
					),
				),
			)
		);

		WP_CLI::add_command(
			'newspack-content-migrator import-staging-site-pages',
			array( $this, 'cmd_import_staging_site_pages' ),
			array(
				'shortdesc' => 'Imports pages which were exported from the Staging site',
				'synopsis'  => array(
					array(
						'type'        => 'assoc',
						'name'        => 'input-dir',
						'description' => 'Full path to the location of the XML file containing staging files.',
						'optional'    => false,
						'repeating'   => false,
					),
				),
			)
		);

		WP_CLI::add_command(
			'newspack-content-migrator delete-export-postmeta',
			array( $this, 'cmd_delete_export_postmeta' ),
			array(
				'shortdesc' => 'Removes the postmeta with original ID which gets set on all exported posts/pages.',
			)
		);

		WP_CLI::add_command(
			'newspack-content-migrator remove-first-image-from-post-body',
			array( $this, 'remove_first_image_from_post_body' ),
			array(
				'shortdesc' => 'Remove the first image from the post body, usefull to normalize the posts content in case some contains the featured image in their body and others not.',
				'synopsis'  => array(),
			)
		);

		WP_CLI::add_command(
			'newspack-content-migrator remove-shortcodes-from-post-body',
			array( $this, 'remove_shortcodes_from_post_body' ),
			array(
				'shortdesc' => 'Remove shortcodes from post body.',
				'synopsis'  => array(
					array(
						'type'        => 'flag',
						'name'        => 'dry-run',
						'description' => 'Do a dry run simulation and don\'t actually edit the posts content.',
						'optional'    => true,
						'repeating'   => false,
					),
					array(
						'type'        => 'assoc',
						'name'        => 'shortcodes',
						'description' => 'List of shortcodes to delete from all the posts content separated by a comma (e.g. shortcode1,shortcode2)',
						'optional'    => false,
						'repeating'   => false,
					),
					array(
						'type'        => 'assoc',
						'name'        => 'post_ids',
						'description' => 'IDs of posts and pages to remove shortcodes from their content separated by a comma (e.g. 123,456)',
						'optional'    => true,
						'repeating'   => false,
					),
				),
			)
		);
	}

	/**
	 * Callable for export-posts command.
	 *
	 * @param array $args
	 * @param array $assoc_args
	 */
	public function cmd_export_posts( $args, $assoc_args ) {
		$output_dir   = isset( $assoc_args['output-dir'] ) ? $assoc_args['output-dir'] : null;
		$output_file  = isset( $assoc_args['output-xml-file'] ) ? $assoc_args['output-xml-file'] : null;
		$post_ids_csv = isset( $assoc_args['post-ids'] ) ? $assoc_args['post-ids'] : null;
		if ( is_null( $output_dir ) ) {
			WP_CLI::error( 'Invalid output dir.' );
		}
		if ( is_null( $output_file ) ) {
			WP_CLI::error( 'Invalid output file.' );
		}
		if ( is_null( $post_ids_csv ) ) {
			WP_CLI::error( 'One of these is mandatory: post-ids or created-from' );
		}

		$post_ids = explode( ',', $post_ids_csv );

		WP_CLI::line( sprintf( 'Exporting post IDs %s to %s...', implode( ',', $post_ids ), $output_dir . '/' . $output_file ) );

		$this->migrator_export_posts( $post_ids, $output_dir, $output_file );

		WP_CLI::success( 'Done.' );
	}

	/**
	 * Exports posts and sets a meta with the original ID when it was exported.
	 *
	 * @param array  $post_ids    Post IDs.
	 * @param string $output_dir  Output dir.
	 * @param string $output_file Output file.
	 *
	 * @return bool
	 */
	public function migrator_export_posts( $post_ids, $output_dir, $output_file ) {
		if ( empty( $post_ids ) ) {
			WP_CLI::warning( 'No posts to export.' );
			return false;
		}

		wp_cache_flush();
		foreach ( $post_ids as $key => $post_id ) {
			update_post_meta( $post_id, self::META_KEY_ORIGINAL_ID, $post_id );
		}

		wp_cache_flush();
		$post_ids = array_values( $post_ids );
		$this->export_posts( $post_ids, $output_dir, $output_file );

		return true;
	}

	/**
	 * Actual exporting of posts to file.
	 * NOTE: this function doesn't set the self::META_KEY_ORIGINAL_ID meta on exported posts, so be sure that's what you want to do.
	 *       Otherwise, use the self::migrator_export_posts() function to set the meta, too.
	 *
	 * @param array  $post_ids    Post IDs.
	 * @param string $output_dir  Output dir.
	 * @param string $output_file Output file.
	 */
	private function export_posts( $post_ids, $output_dir, $output_file ) {
		$post_ids_csv = implode( ',', $post_ids );
		WP_CLI::runcommand( "export --post__in=$post_ids_csv --dir=$output_dir --filename_format=$output_file --with_attachments" );
	}

	/**
	 * Callable for import-posts command.
	 *
	 * @param array $args
	 * @param array $assoc_args
	 */
	public function cmd_import_posts( $args, $assoc_args ) {
		$file = isset( $assoc_args['file'] ) ? $assoc_args['file'] : null;
		if ( is_null( $file ) || ! file_exists( $file ) ) {
			WP_CLI::error( 'Invalid file provided.' );
		}

		WP_CLI::line( 'Importing posts...' );

		$this->import_posts( $file );
		wp_cache_flush();

		WP_CLI::success( 'Done.' );
	}

	/**
	 * @param string $file File for Import.
	 *
	 * @return mixed
	 */
	public function import_posts( $file ) {
		$options = array(
			'return' => true,
		);
		$output  = WP_CLI::runcommand( "import $file --authors=create", $options );

		return $output;
	}

	/**
	 * Exports all Pages from the Staging site.
	 *
	 * @param $args
	 * @param $assoc_args
	 */
	public function cmd_export_all_staging_site_pages( $args, $assoc_args ) {
		$output_dir = isset( $assoc_args['output-dir'] ) ? $assoc_args['output-dir'] : null;
		if ( is_null( $output_dir ) ) {
			WP_CLI::error( 'Invalid output dir.' );
		}

		WP_CLI::line( sprintf( 'Exporting all Staging site Pages to %s ...', $output_dir . '/' . self::STAGING_PAGES_EXPORT_FILE ) );

		wp_reset_postdata();
		$post_ids = $this->posts_logic->get_all_posts_ids( 'page' );
		$this->migrator_export_posts( $post_ids, $output_dir, self::STAGING_PAGES_EXPORT_FILE );

		WP_CLI::success( 'Done.' );
	}

	/**
	 * Updates titles of given pages with a prefix, and sets their statuses to drafts.
	 *
	 * @param array $page_ids IDs of pages.
	 */
	public function preserve_unique_pages_from_live_as_drafts( $page_ids ) {
		foreach ( $page_ids as $id ) {
			$page              = get_post( $id );
			$page->post_title  = '[Live] ' . $page->post_title;
			$page->post_name  .= '-live_migrated';
			$page->post_status = 'draft';
			wp_update_post( $page );
		}
	}

	/**
	 * Callable for import-posts command.
	 *
	 * @param array $args
	 * @param array $assoc_args
	 */
	public function cmd_import_staging_site_pages( $args, $assoc_args ) {
		$input_dir = isset( $assoc_args['input-dir'] ) ? $assoc_args['input-dir'] : null;
		if ( is_null( $input_dir ) || ! file_exists( $input_dir ) ) {
			WP_CLI::error( 'Invalid input dir.' );
		}

		// The following Page migration strategy aims to achieve two things:
		// - to keep all the Pages from the Staging site,
		// - to keep only the unique (new, different) pages from Live, but import them as Drafts, with their titles and permalinks updated.

		WP_CLI::line( 'Importing all Pages from Staging site and new pages from the Live site...' );

		// First delete those Live Pages which we're not keeping.
		WP_CLI::line( 'First clearing all Live site Pages which will be imported from Staging site to prevent duplicates...' );
		$this->delete_duplicate_live_site_pages();

		// Get IDs of the unique Live Pages which we are keeping.
		wp_reset_postdata();
		$pages_live_ids = $this->posts_logic->get_all_posts_ids( 'page' );

		// Update the remaining Live Pages which we are keeping: save them as drafts, and change their permalinks and titles.
		if ( count( $pages_live_ids ) > 0 ) {
			$this->preserve_unique_pages_from_live_as_drafts( $pages_live_ids );
			wp_cache_flush();
		} else {
			WP_CLI::warning( 'No unique Live site Pages found, continuing.' );
		}

		// Import Pages from Staging site.
		$file = $input_dir . '/' . self::STAGING_PAGES_EXPORT_FILE;
		WP_CLI::line( 'Importing Staging site Pages from  ' . $file . ' (uses `wp import` and might take a bit longer) ...' );
		$this->import_posts( $file );

		wp_cache_flush();

		WP_CLI::success( 'Done.' );
	}

	/**
	 * Deletes all Live site Pages which will not be preserved, since they'll be imported from the Staging site anyway.
	 */
	public function delete_duplicate_live_site_pages() {
		$post_ids = $this->get_all_pages_duplicates_on_staging();
		if ( empty( $post_ids ) ) {
			WP_CLI::success( 'No Pages found.' );
			return;
		}

		$progress = \WP_CLI\Utils\make_progress_bar( 'Deleting ' . count( $post_ids ) . ' pages...', count( $post_ids ) );
		foreach ( $post_ids as $id ) {
			$progress->tick();
			wp_delete_post( $id, true );
		}
		$progress->finish();

		wp_reset_postdata();
		wp_cache_flush();
	}

	/**
	 * Gets all pages which were exported from Staging and that are also found in current wp_posts.
	 *
	 * @return array|void Array of page IDs.
	 */
	public function get_all_pages_duplicates_on_staging() {
		global $wpdb;

		$ids = array();
		wp_reset_postdata();

		$staging_posts_table = 'staging_' . $wpdb->prefix . 'posts';
		$posts_table         = $wpdb->prefix . 'posts';
		// Notes on joining: post_content will have different hostnames; guid is misleading (new page on live would get the same guid).
		$sql = "SELECT wp.ID FROM {$posts_table} wp
			JOIN {$staging_posts_table} swp
				ON swp.post_name = wp.post_name
				AND swp.post_title = wp.post_title
				AND swp.post_status = wp.post_status
			WHERE wp.post_type = 'page';";
		// phpcs:ignore -- false positive, all params are fully sanitized.
		$results = $wpdb->get_results( $sql );

		if ( empty( $results ) ) {
			return;
		}

		foreach ( $results as $result ) {
			$ids[] = $result->ID;
		}
		return $ids;
	}

	/**
	 * Callable for remove-export-postmeta command.
	 *
	 * @param array $args
	 * @param array $assoc_args
	 */
	public function cmd_delete_export_postmeta() {
		WP_CLI::line( sprintf( 'Deleting %s postmeta from all ther posts and pages...', self::META_KEY_ORIGINAL_ID ) );

		$args  = array(
			'post_type'   => array( 'post', 'page' ),
			'post_status' => 'publish',
			'meta_query'  => array(
				array(
					'key' => self::META_KEY_ORIGINAL_ID,
				),
			),
		);
		$query = new \WP_Query( $args );
		$posts = $query->posts;

		foreach ( $posts as $post ) {
			delete_post_meta( $post->ID, self::META_KEY_ORIGINAL_ID );
		}

		WP_CLI::success( 'Done.' );
	}

	/**
	 * Callable for `newspack-content-migrator remove-first-image-from-post-body`.
	 */
	public function remove_first_image_from_post_body() {
		WP_CLI::confirm( "This will remove the first image from the post body if it's on a shortcode format ([caption ...]<img src=...>[/caption]), do you want to continue?" );

		$this->posts_logic->throttled_posts_loop(
			array(
				'post_type'   => 'post',
				'post_status' => array( 'publish' ),
			),
			function( $post ) {
				global $wpdb;

				if ( substr( $post->post_content, 0, strlen( '[caption' ) ) === '[caption' ) {
					$start_with_images[] = $post->ID;

					$pattern = get_shortcode_regex();
					if ( preg_match_all( '/' . $pattern . '/s', $post->post_content, $matches ) && array_key_exists( 2, $matches ) && in_array( 'caption', $matches[2] ) ) {
						$index = 0;
						$count = 0;
						// Remove the first image shortcode from the content.
						foreach ( $matches[2] as $match ) {
							if ( 'caption' === $match ) {
								// Found our first image.
								$index = $count;
								break; // We've done enough.
							}
							$count++;
						};
						// Remove first gallery from content.
						$content = str_replace( $matches[0][ $index ], '', $post->post_content );

						if ( $content !== $post->post_content ) {
							// phpcs:ignore WordPress.DB.DirectDatabaseQuery
							$wpdb->update(
								$wpdb->prefix . 'posts',
								array( 'post_content' => $content ),
								array( 'ID' => $post->ID )
							);

							WP_CLI::line( sprintf( 'Updated post: %d', $post->ID ) );
						}
					}
				}
			}
		);
	}

	/**
	 * Callable for `newspack-content-migrator remove-shortcodes-from-post-body`.
	 */
	public function remove_shortcodes_from_post_body( $args, $assoc_args ) {
		$shortcodes = isset( $assoc_args['shortcodes'] ) ? explode( ',', $assoc_args['shortcodes'] ) : null;
		$post_ids   = isset( $assoc_args['post_ids'] ) ? explode( ',', $assoc_args['post_ids'] ) : null;
		$dry_run    = isset( $assoc_args['dry-run'] ) ? true : false;

		if ( is_null( $shortcodes ) || empty( $shortcodes ) ) {
			WP_CLI::error( 'Invalid shortcodes list.' );
		}

		if ( $dry_run ) {
			WP_CLI::warning( 'Dry mode, no changes are going to affect the database' );
		} else {
			WP_CLI::confirm( 'This will remove all the shortcodes with their content from all the posts content, do you want to continue?' );
		}

		$this->posts_logic->throttled_posts_loop(
			array(
				'post_type'   => array( 'post', 'page' ),
				'post_status' => array( 'publish' ),
				'post__in'    => $post_ids,
			),
			function( $post ) use ( $shortcodes, $dry_run ) {
				$post_content_blocks = array();

				foreach ( parse_blocks( $post->post_content ) as $content_block ) {
					// remove shortcodes from Core shortcode, Core HTML, Paragraph, and Classic blocks.
					if (
						'core/shortcode' === $content_block['blockName']
						|| 'core/html' === $content_block['blockName']
						|| ( 'core/paragraph' === $content_block['blockName'] )
						|| ( ! $content_block['blockName'] )
					) {
						$pattern = get_shortcode_regex( $shortcodes );

						if ( preg_match_all( '/' . $pattern . '/s', $content_block['innerHTML'], $matches )
							&& array_key_exists( 2, $matches )
						) {
							$content_without_shortcodes = $this->strip_shortcodes( $shortcodes, $content_block['innerHTML'] );
							// remove resulting empty paragraphs if any.
							$cleaned_content = trim( preg_replace( '/<p[^>]*><\\/p[^>]*>/', '', $content_without_shortcodes ) );

							if ( empty( $cleaned_content ) ) {
								$content_block = null;
								continue;
							}

							$content_block['innerHTML']    = $cleaned_content;
							$content_block['innerContent'] = array_map(
								function( $inner_content ) use ( $shortcodes ) {
									return $this->strip_shortcodes( $shortcodes, $inner_content );
								},
								$content_block['innerContent']
							);
						}
					}

					$post_content_blocks[] = $content_block;
				}

				$post_content_without_shortcodes = serialize_blocks( $post_content_blocks );

				if ( $post_content_without_shortcodes !== $post->post_content ) {
					if ( ! $dry_run ) {
						$update = wp_update_post(
							array(
								'ID'           => $post->ID,
								'post_content' => $post_content_without_shortcodes,
							)
						);

						if ( is_wp_error( $update ) ) {
							$this->log( self::SHORTCODES_LOGS, sprintf( 'Failed to update post %d because %s', $post->ID, $update->get_error_message() ) );
						} else {
							$this->log( self::SHORTCODES_LOGS, sprintf( 'Post %d cleaned from shortcodes.', $post->ID ) );
						}
					} else {
						WP_CLI::line( sprintf( 'Post %d cleaned from shortcodes.', $post->ID ) );
						WP_CLI::line( $post_content_without_shortcodes );
					}
				}
			}
		);
	}

	/**
	 * Strip shortcodes from content.
	 *
	 * @param string[] $shortcodes Shortcodes to strip.
	 * @param string   $text Content to strip the shortcodes from.
	 * @return string
	 */
	private function strip_shortcodes( $shortcodes, $text ) {
		if ( ! ( empty( $shortcodes ) || ! is_array( $shortcodes ) ) ) {
			$tagregexp = join( '|', array_map( 'preg_quote', $shortcodes ) );
			$regex     = '\[(\[?)';
			$regex    .= "($tagregexp)";
			$regex    .= '\b([^\]\/]*(?:\/(?!\])[^\]\/]*)*?)(?:(\/)\]|\](?:([^\[]*+(?:\[(?!\/\2\])[^\[]*+)*+)\[\/\2\])?)(\]?)';

			$text = preg_replace( "/$regex/s", '', $text );
		}

		return $text;
	}

	/**
	 * When exporting objects, the PostsMigrator sets PostsMigrator::META_KEY_ORIGINAL_ID meta key with the ID they had at the
	 * time. This function gets the new/current ID which changed when they were imported.
	 *
	 * @param $original_post_id ID.
	 *
	 * @return |null
	 */
	public function get_current_post_id_from_original_post_id( $original_post_id ) {
		global $wpdb;

		$new_id = $wpdb->get_var(
			$wpdb->prepare(
				"SELECT p.ID
			FROM {$wpdb->prefix}posts p
			JOIN {$wpdb->prefix}postmeta pm ON pm.post_id = p.ID
			AND pm.meta_key = '%s'
			AND pm.meta_value = %d ; ",
				self::META_KEY_ORIGINAL_ID,
				$original_post_id
			)
		);

		return isset( $new_id ) ? $new_id : null;
	}

	/**
	 * Simple file logging.
	 *
	 * @param string  $file    File name or path.
	 * @param string  $message Log message.
	 * @param boolean $to_cli Display the logged message in CLI.
	 */
	private function log( $file, $message, $to_cli = true ) {
		$message .= "\n";
		if ( $to_cli ) {
			WP_CLI::line( $message );
		}
		file_put_contents( $file, $message, FILE_APPEND );
	}
}
